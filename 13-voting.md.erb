---
title: Votazioni
slug: votazioni
date: 0013/01/01
number: 13
contents: Implementare un sistema che consenta agli utenti di votare i post.|Classificare i post in base al voto su una pagina dei post "migliori".|Scrivere un generico handlebar helper.|Approfondimento sulla sicurezza dei dati.|Alcune interessanti considerazioni riguardanti MongoDB.
paragraphs: 49
---

Adesso che il sito sta guadagnando popolarità, trovare i link migliori sta rapidamente diventando complicato. E' necessario un qualche sistema di classificazione con cui ordinare i post.

Si potrebbe implementare un complesso sistema di classificazione basato su karma, decadimento del punteggio a tempo, e svariati altri parametri (la maggior parte dei quali implementati in (Telescope)[http://telesc.pe/], il fratello maggiore di Microscope). Nella nostra applicazione invece si punta alla semplicità, per cui i post saranno classificati in base al numero di voti ricevuti.

Per cominciare, verrà fornita agli utenti la possibilità di votare un post.

### Modello dei Dati

Per determinare se visualizzare agli utenti il pulsante di upvote o meno, per ciascun post verrà salvata la lista degli utenti che lo hanno votato, consentendo allo stesso tempo di evitare che un utente voti più di una volta.

<% note do %>

### Riservatezza dei Dati & Pubblicazioni

Le liste dei votanti saranno pubblicate a tutti gli utenti, che di conseguenza renderà i dati automaticamente e pubblicamente accedibili dalla console del browser.

Questo è il tipico problema di riservatezza dei dati causato dalla modalità in cui le collezioni funzionano. Ad esempio, si vuole consentire agli utenti la ricerca di coloro che hanno votato i loro post? Nel caso in questione rendere tali informazioni pubblicamente accedibili non ha reali conseguenze, ma è importante avere almeno consapevolezza del problema.

Da notare che se si volesse limitare l'accesso ad alcune di queste informazioni, ci si dovrebbe assicurare che al client non sia consentito smanettare con le opzioni dei campi `fields` della pubblicazione, sia rimuovento la proprietà lato server, sia evitando di passare per intero le opzioni dal client al server.

<% end %>

Per semplificare il conteggio del numero di voti per ciascun post, il totale dei voti per ciascun post verrà denormalizzato. Verranno quindi aggiunti due attributi ai post, `upvoters` e `votes`. 

~~~js
// Dati di esempio 
if (Posts.find().count() === 0) {
  var now = new Date().getTime();
  
  // crea 2 utenti
  var tomId = Meteor.users.insert({
    profile: { name: 'Tom Coleman' }
  });
  var tom = Meteor.users.findOne(tomId);
  var sachaId = Meteor.users.insert({
    profile: { name: 'Sacha Greif' }
  });
  var sacha = Meteor.users.findOne(sachaId);
  
  var telescopeId = Posts.insert({
    title: 'Introducing Telescope',
    userId: sacha._id,
    author: sacha.profile.name,
    url: 'http://sachagreif.com/introducing-telescope/',
    submitted: now - 7 * 3600 * 1000,
    commentsCount: 2,
    upvoters: [], votes: 0
  });
  
  Comments.insert({
    postId: telescopeId,
    userId: tom._id,
    author: tom.profile.name,
    submitted: now - 5 * 3600 * 1000,
    body: 'Interesting project Sacha, can I get involved?'
  });
  
  Comments.insert({
    postId: telescopeId,
    userId: sacha._id,
    author: sacha.profile.name,
    submitted: now - 3 * 3600 * 1000,
    body: 'You sure can Tom!'
  });
  
  Posts.insert({
    title: 'Meteor',
    userId: tom._id,
    author: tom.profile.name,
    url: 'http://meteor.com',
    submitted: now - 10 * 3600 * 1000,
    commentsCount: 0,
    upvoters: [], votes: 0
  });
  
  Posts.insert({
    title: 'The Meteor Book',
    userId: tom._id,
    author: tom.profile.name,
    url: 'http://themeteorbook.com',
    submitted: now - 12 * 3600 * 1000,
    commentsCount: 0,
    upvoters: [], votes: 0
  });
  
  for (var i = 0; i < 10; i++) {
    Posts.insert({
      title: 'Test post #' + i,
      author: sacha.profile.name,
      userId: sacha._id,
      url: 'http://google.com/?q=test-' + i,
      submitted: now - i * 3600 * 1000,
      commentsCount: 0,
      upvoters: [], votes: 0
    });
  }
}
~~~
<%= caption "server/fixtures.js" %>
<%= highlight "22, 48, 58, 69" %>

////

~~~js
//...

// verifica che non ci siano post precedenti con lo stesso link
if (postAttributes.url && postWithSameLink) {
  throw new Meteor.Error(302, 
    'This link has already been posted', 
    postWithSameLink._id);
}

// reperisce le chiavi abilitate
var post = _.extend(_.pick(postAttributes, 'url', 'title', 'message'), {
  userId: user._id, 
  author: user.username, 
  submitted: new Date().getTime(),
  commentsCount: 0,
  upvoters: [], 
  votes: 0
});

var postId = Posts.insert(post);

return postId;

//...
~~~
<%= caption "collections/posts.js" %>
<%= highlight "16~17" %>

### Implementazione dei template per le votazioni

Per prima cosa, verrà aggiunto un pulsante al post parziale:

~~~html
<template name="postItem">
  <div class="post">
    <a href="#" class="upvote btn">⬆</a>
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
      <p>
        {{votes}} Votes,
        submitted by {{author}},
        <a href="{{pathFor 'postPage'}}">{{commentsCount}} comments</a>
        {{#if ownPost}}<a href="{{pathFor 'postEdit'}}">Edit</a>{{/if}}
      </p>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "3,7" %>

<%= screenshot "13-1", "Il pulsante per votare" %>

Verrà quindi chiamato un metodo lato server per eseguire l'upvote quando l'utente clicca sul pulsante:

~~~js
//...

Template.postItem.events({
  'click .upvote': function(e) {
    e.preventDefault();
    Meteor.call('upvote', this._id);
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>
<%= highlight "3~8" %>

////

~~~js
Meteor.methods({
  post: function(postAttributes) {
    //...
  },
  
  upvote: function(postId) {
    var user = Meteor.user();
    // verifica che l'utente sia loggato
    if (!user)
      throw new Meteor.Error(401, "You need to login to upvote");
    
    var post = Posts.findOne(postId);
    if (!post)
      throw new Meteor.Error(422, 'Post not found');
    
    if (_.include(post.upvoters, user._id))
      throw new Meteor.Error(422, 'Already upvoted this post');
    
    Posts.update(post._id, {
      $addToSet: {upvoters: user._id},
      $inc: {votes: 1}
    });
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "6~23" %>

<%= commit "13-1", "Aggiunto semplice algoritmo per votazione." %>

Questo methodo è autoesplicativo. Si eseguono alcuni controlli preventivi per evitare che l'utente sia loggato e che il post esista realmente. Quindi si controlla che l'utente non abbia già espresso il suo voto per il post, quindi si incrementa il punteggio totale del voto e aggiunge l'utente alla lista dei votanti.

Questa ultima operazione si rivela interessante, in quanto vengono utilizzato due operatori di Mongo speciali. Ce ne sono molti di più da imparare, ma questi sono estremamente utili: `$addToSet` aggiunge un elemento ad un array se non già incluso, mentre `$inc` semplicemente incrementa il valore di un campo di tipo intero.

### Ritocchi all'Interfaccia Utente

Se l'utente non è loggato, oppure ha già votato, non sarà in grado di votare. Per evidenziare questo caso sull'interfaccia, verrà utilizzata una funzione di supporto che aggiunge, ove necessario, la classe CSS `disabled` al pulsante per la votazione.

~~~html
<template name="postItem">
  <div class="post">
    <a href="#" class="upvote btn {{upvotedClass}}">⬆</a>
    <div class="post-content">
      //...
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "3" %>

~~~js
Template.postItem.helpers({
  ownPost: function() {
    //...
  },
  domain: function() {
    //...
  },
  upvotedClass: function() {
    var userId = Meteor.userId();
    if (userId && !_.include(this.upvoters, userId)) {
      return 'btn-primary upvotable';
    } else {
      return 'disabled';
    }
  }
});

Template.postItem.events({
  'click .upvotable': function(e) {
    e.preventDefault();
    Meteor.call('upvote', this._id);
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>
<%= highlight "8~15, 19" %>

Si sta cambiando la classe da `.upvote` a `.upvotable`, quindi è opportuno non tralasciare di modificare il gestore dell'evento click.

<%= screenshot "13-2", "Disabilitazione del pulsante per la votazione." %>

<%= commit "13-2", "Link in grigio se non autenticato o già votato." %>

Ora, si può notare che i post con un singolo voto sono etichettati come "1 vote__s__", vediamo quindi come formattare il plurale in modo appropriato. Mettere in forma plurale può essere un processo complicato, ma per adesso verrà affrontato in modo semplice. Si implementerà una funzione di supporto `Handlebars` general, ovunque utilizzabile.

~~~js
Handlebars.registerHelper('pluralize', function(n, thing) {
  // fairly stupid pluralizer
  if (n === 1) {
    return '1 ' + thing;
  } else {
    return n + ' ' + thing + 's';
  }
});
~~~
<%= caption "client/helpers/handlebars.js" %>

Le funzioni che sono state create sono legate ai relativi manager e template. Ma utilizzando `Handlebars.registerHelper` viene creata una funzione di supporto _globale_ che può essere utilizzata in qualunque template:

~~~html
<template name="postItem">
//...
<p>
  {{pluralize votes "Vote"}},
  submitted by {{author}},
  <a href="{{pathFor 'postPage'}}">{{pluralize commentsCount "comment"}}</a>
  {{#if ownPost}}<a href="{{pathFor 'postEdit'}}">Edit</a>{{/if}}
</p>
//...
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>
<%= highlight "4, 6" %>

<%= screenshot "13-3", "Perfezionamento della forma plurale" %>

<%= commit "13-3", "Aggiunta funzione per formattare il testo in forma plurale." %>

Adesso si dovrebbe vedere `1 vote`.

### Miglioramento dell'Algoritmo di Votazione

Il codice per votare sembra buono, ma può ancora essere migliorato. Nel metodo `upvote` vengono eseguite 2 chiamate a Mongo: la prima per ottenere il post, l'altra per modificarlo.

Ci sono due problemi. Per prima cosa, è inefficiente accedere al database per 2 volte. Ma ben più importante, introduce una corsa critica. L'algoritmo implementato è il seguente:

1. Legge il post dal database
2. Verifica se l'utente ha votato
3. In caso negativo, esegue il voto 

Cosa succede se lo stesso utente vota nuovamente lo stesso post durante i passi 1 e 3? Questa versione consente all'utente di votare 2 volte per lo stesso post. Fortunatamente, Mongo fornisce un metodo più efficace combinando i passi 1-3 in un singolo comando Mongo:

~~~js
Meteor.methods({
  post: function(postAttributes) {
    //...
  },
  
  upvote: function(postId) {
    var user = Meteor.user();
    // ensure the user is logged in
    if (!user)
      throw new Meteor.Error(401, "You need to login to upvote");
    
    Posts.update({
      _id: postId, 
      upvoters: {$ne: user._id}
    }, {
      $addToSet: {upvoters: user._id},
      $inc: {votes: 1}
    });
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "12~15" %>

<%= commit "13-4", "Algoritmo di votazione migliorato." %>

Il codice si traduce in: "trova tutti i post con questo `id` per cui l'utente non ha ancora votato, e aggiornali in questo modo". Se l'utente _non_ ha ancora votato, il post con quell'`id` sarà ovviamente trovato. D'altro canto, se l'utente ha *già* votato, allora la ricerca non troverà alcun documento, e conseguentemente non succederà niente.

Il solo problema adesso adesso è che non si può informare l'utente riguardo la votazione già eseguita per il post (poiché è stata eliminata la chiamata al database che eseguiva la verifica). Ad ogni modo, l'utente dovrebbe esserne a conoscenza dato che il pulsante "upvote" nell'interfaccia utente è disabilitato.

<% note do %>

### Latency Compensation

////

~~~js
> Posts.update(postId, {$set: {votes: 10000}});
~~~
<%= caption "Browser console" %>

////

////

////

////

////

<% end %>

### Ranking the Front Page Posts

////

////

////

////

~~~js
PostsListController = RouteController.extend({
  template: 'postsList',
  increment: 5, 
  limit: function() { 
    return parseInt(this.params.postsLimit) || this.increment; 
  },
  findOptions: function() {
    return {sort: this.sort, limit: this.limit()};
  },
  waitOn: function() {
    return Meteor.subscribe('posts', this.findOptions());
  },
  posts: function() {
    return Posts.find({}, this.findOptions());
  },
  data: function() {
    var hasMore = this.posts().fetch().length === this.limit();
    return {
      posts: this.posts(),
      nextPath: hasMore ? this.nextPath() : null
    };
  }
});

NewPostsListController = PostsListController.extend({
  sort: {submitted: -1, _id: -1},
  nextPath: function() {
    return Router.routes.newPosts.path({postsLimit: this.limit() + this.increment})
  }
});

BestPostsListController = PostsListController.extend({
  sort: {votes: -1, submitted: -1, _id: -1},
  nextPath: function() {
    return Router.routes.bestPosts.path({postsLimit: this.limit() + this.increment})
  }
});

Router.map(function() {
  this.route('home', {
    path: '/',
    controller: NewPostsListController
  });
  
  this.route('newPosts', {
    path: '/new/:postsLimit?',
    controller: NewPostsListController
  });
  
  this.route('bestPosts', {
    path: '/best/:postsLimit?',
    controller: BestPostsListController
  });
  // ..
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "8,16,21~34,36~49" %>

////

////

////

~~~html
<template name="header">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="{{pathFor 'home'}}">Microscope</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li>
            <a href="{{pathFor 'newPosts'}}">New</a>
          </li>
          <li>
            <a href="{{pathFor 'bestPosts'}}">Best</a>
          </li>
          {{#if currentUser}}
            <li>
              <a href="{{pathFor 'postSubmit'}}">Submit Post</a>
            </li>
            <li class="dropdown">
              {{> notifications}}
            </li>
          {{/if}}
        </ul>
        <ul class="nav pull-right">
          <li>{{loginButtons}}</li>
        </ul>
      </div>
    </div>
  </header>
</template>
~~~
<%= caption "client/views/include/header.html" %>
<%= highlight "9, 15~21" %>

////

<%= screenshot "13-4", "Ranking by points" %>

<%= commit "13-5", "Added routes for post lists, and pages to display them." %>

### A Better Header

////

////

~~~html
<template name="header">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="{{pathFor 'home'}}">Microscope</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li class="{{activeRouteClass 'home' 'newPosts'}}">
            <a href="{{pathFor 'newPosts'}}">New</a>
          </li>
          <li class="{{activeRouteClass 'bestPosts'}}">
            <a href="{{pathFor 'bestPosts'}}">Best</a>
          </li>
          {{#if currentUser}}
            <li class="{{activeRouteClass 'postSubmit'}}">
              <a href="{{pathFor 'postSubmit'}}">Submit Post</a>
            </li>
            <li class="dropdown">
              {{> notifications}}
            </li>
          {{/if}}
        </ul>
        <ul class="nav pull-right">
          <li>{{loginButtons}}</li>
        </ul>
      </div>
    </div>
  </header>
</template>
~~~
<%= caption "client/views/includes/header.html" %>
<%= highlight "9,12,15,19" %>

~~~js
Template.header.helpers({
  activeRouteClass: function(/* route names */) {
    var args = Array.prototype.slice.call(arguments, 0);
    args.pop();
    
    var active = _.any(args, function(name) {
      return Router.current().route.name === name
    });
    
    return active && 'active';
  }
});
~~~
<%= caption "client/views/includes/header.js" %>

<%= screenshot "13-5", "Showing the active page" %>

<% note do %>

### Helper Arguments

////

////

////

<% end %>

////

////

<%= commit "13-6", "Added active classes to the header." %>

////
