---
title: Collections
slug: collections
date: 0004/01/01
number: 4
contents: Principali funzinalità del nucleo di Meteor, collezioni in tempo reale.| Comprendere come funziona la sincronizzazine dei dati in Meteor.|Integrare collezioni con i nostri template.|Trasformare il nostro prototipo in un'applicazione realtime funzionante!
paragraphs: 72
---

Nel capitolo uno, abbiamo parlato della caratteristica principale di Meteor: la sincronizzazione automatica dei dati tra client e server.

In questo capitolo, analizzeremo più nel dettaglio questo meccanismo, osservando il funzionamento della tecnologia chiave che lo permette: la collezione (`collection`) di Meteor.

Stiamo costruendo un'applicazione di nodizie social, e la prima cosa che vogliamo fare è creare una lista di link che le persone hanno inserito. Chiameremo "post" ognuno di questi oggetti.

Naturalmente, dovremo salvare questi posta da qualche parte. Meteor installa anche Mongo che viene eseguito sul vostro server e funge da base di dati *persistente*.

Dunque, anche se il browser dell'utente può contenere alcune informazioni di stato (ad esempio la pagina corrente, o il commento che stà scrivendo in quel momento), il server, e più precisamente Mongo, contiene la sorgente di dati permanente canonica. *Canonica* significa che è la stessa per tutti gli utenti: ogni utente può essere su di una pagina diversa, ma la lista originale dei post è la stessa per tutti.

Questi dati sono salvati in Meteor all'interno di una **Collezione**. Una collezione è una struttura dati speciale che, per mezzo di pubblicazioni e sottoscrizioni, si prende cura della sincronizzazione tempo reale dei dati tra il database Mongo e ogni browser degli utenti connessi, in entrambe le direzioni. Vediamo come.

Vogliamo che i post siano permanenti e condivisi tra gli utenti, inizieremo quindi creando una collezione chiamata `Posts` dentro cui salvarli. Se non lo avete ancora fatto, create la cartella `collections/` dentro la cartella principale della vostra applicazione, e dentro essa il file `posts.js`. Quindi aggiungete:

~~~js
Posts = new Meteor.Collection('posts');
~~~
<%= caption "collections/posts.js" %>

<%= commit "4-1", "Added a posts collection" %>

Il codice che non si trova all'interno delle cartelle `client/` e `server/` verrà eseguito in *entrambi* i contesti. Per questo motivo la collezione `Posts` risulterà disponibile sia lato client che lato server. Comunque, il ruolo della collezione in ognuno dei due ambienti è molto diverso.

<% note do %>

### Usare Var O Non Usare Var?

In Meteor, la keyword `var` limita la visibilità di un oggetto al file corrente. Vogliamo rendere la collezione `Posts` visibile a tutta l'applicazione, motivo per cui la stiamo omettendo dalla sua dichiarazione.

<% end %>

Sul server la collezione ha il compito di parlare con il database Mongo, leggendo e scrivendo qualsiasi cambiamento. Da questo punto di vista, può essere paragonata ad una libreria standard per database. Sul client, diversamente, la collezione è una copia *sicura* di un *sottoinsieme* della reale collezione canonica. La collezione lato client è mantenuta costantemente aggiornata, in modo quasi del tutto trasparente, con quel sottoinsieme di dati in tempo reale.

<% note do %>

### Console vs Console vs Console

In questo capitolo inizieremo a fare uso della **console del browser**, che non va confusa con il **terminale** o **la shell di Mongo**. Di seguito proponiamo una breve guida per ognuna di esse.

#### Terminal

<%= screenshot "terminal", "Il Terminale" %>

- Eseguito dal tuo sistema operativo.
- `console.log()` eseguito **lato server** produce output qui.
- Prompt: `$`.
- Conosciuto anche come: Shell, Bash.

#### Console del Browser

<%= screenshot "browser-console", "La Console del Browser" %>

- Richiamata dall'interno del browser, esegue codice JavaScript.
- `console.log()` eseguito **lato client** produce output qui.
- Prompt: `❯`.
- Conosciuta anche come: Console JavaScript, Console dei DevTools

#### Shell di Mongo

<%= screenshot "mongo-shell", "La Shell di Mongo" %>

- Lanciata dal Terminale con `meteor mongo` o `mrt mongo`.
- Permette l'accecco diretto al database dell'applicazione.
- Prompt: `>`.
- Conosciuta anche come: Console di Mongo.

Notiamo che, per tutte, non è necessario digitare il carattere del prompt (`$`, `❯`, o `>`) come parte dei comandi. Possiamo anche assumere che ogni riga che *non* inizi con il prompt sia il risultato del comando precedente.

<% end %>

### Server-Side Collections

Sul server, la collezione funge da API per il database Mongo. Questo permette, per il codice lato server, di scrivere comandi Mongo come `Posts.insert()` oppure `Posts.update()`: questi modificheranno la collezione `posts` in Mongo.

Per guardare all'interno del database Mongo, aprite una seconda finestra del terminale (mentre `meteor` è ancora in esecuzione nella prima) e spostatevi nella cartella della vostra app. Eseguite quindi il comando `meteor mongo` per lanciare la shell di Mongo: al suo interno potete digitare i comandi standard di Mongo (e come usuale, potete terminarla con la combinazione di tasti `ctrl+c`). Per fare un esempio, inseriamo un nuovo post:

~~~bash
> db.posts.insert({title: "A new post"});

> db.posts.find();
{ "_id": ObjectId(".."), "title" : "A new post"};
~~~
<%= caption "La Shell di Mongo" %>

<% note do %>

### Mongo su Meteor.com

Se ospotate la vostra applicazione su *.meteor.com, potete comunque accedere alla shell di mongo dell'applicazione funzionante con `meteor mongo myApp`.

E, tanto che ci siamo, potete anche ottenere i log dell'applicazione scrivendo `meteor logs myApp`.

<% end %>

La sintassi di Mongo è familiare, visto che utilizza un'interfaccia JavaScript. Non faremo altre manipolazioni di dati dalla shell di Mongo, ma potremo ritornarci di tanto in tanto giusto per assicurarci di che dati ci sono dentro.

### Client-Side Collections

Le collezioni sono ancora più interessanti viste dal lato client. Quando dichiariamo `Posts = new Meteor.Collection('posts');` sul client, stiamo creando una copia _locale nella cache del browser_ della reale collezione in Mongo. Quando diciamo che una collezione lato client è una "cache", vogliamo dire che contiene un *sottoinsieme* dei dati ai quali offre un accesso molto *rapido*.

È importante capire bene questo concetto perché risulta fondamentale al funzionamento di Meteor. In generale, una collezione lato client consiste in un sottoinsieme di tutti i documenti salvati all'interno della collezione Mongo (dopo tutto, generalmente non vogliamo mandare *tutto* il database al client).

Secondariamente, questi documenti sono salvati nella *memoria del browser*, il che significa che accedervi è praticamente istantaneo. Quando eseguiamo `Posts.find()` sul client per caricare i dati, non ci sono quindi comunicazioni lente con il server o il database, perché i dati sono già pre-caricati.

<% note do %>

### Introducing MiniMongo

L'implementazione Meteor di Mongo per il lato client viene chiamata MiniMongo. Non è ancora un'implementazione perfetta e, occasionalmente, potrete scoprire che alcune funzionalità di Mongo non funzionano in MiniMongo. Nonostante ciò, tutte le funzionalità che copriremo con questo libro funzionano allo stesso modo sia in Mongo che MiniMongo.

<% end %>

### Client-Server Communication

////

////

////

~~~bash
> db.posts.find();
{title: "A new post", _id: ObjectId("..")};
~~~
<%= caption "The Mongo Shell" %>

~~~js
❯ Posts.findOne();
{title: "A new post", _id: LocalCollection._ObjectID};
~~~
<%= caption "First browser console" %>

////

~~~js
❯ Posts.find().count();
1
❯ Posts.insert({title: "A second post"});
'xxx'
❯ Posts.find().count();
2
~~~
<%= caption "First browser console" %>

////

~~~bash
❯ db.posts.find();
{title: "A new post", _id: ObjectId("..")};
{title: "A second post", _id: 'yyy'};
~~~
<%= caption "The Mongo Shell" %>

////

////

~~~js
❯ Posts.find().count();
2
~~~
<%= caption "Second browser console" %>

////

////

////

### Keeping it Real-time

////

////

### Populating the Database

////

////

////

~~~bash
$ meteor reset
~~~

////

////

~~~js
if (Posts.find().count() === 0) {
  Posts.insert({
    title: 'Introducing Telescope',
    author: 'Sacha Greif',
    url: 'http://sachagreif.com/introducing-telescope/'
  });

  Posts.insert({
    title: 'Meteor',
    author: 'Tom Coleman',
    url: 'http://meteor.com'
  });

  Posts.insert({
    title: 'The Meteor Book',
    author: 'Tom Coleman',
    url: 'http://themeteorbook.com'
  });
}
~~~
<%= caption "server/fixtures.js" %>

<%= commit "4-2", "Added data to the posts collection." %>

////

////

### Wiring the data to our HTML with helpers

////

~~~js
❯ Posts.find().fetch();
~~~
<%= caption "Browser console" %>

////

////

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find();
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "2~4" %>

<%= commit "4-3", "Wired collection into `postsList` template." %>

<% note do %>

### Find & Fetch

////

////

<% end %>

////

<%= screenshot "4-3", "Using live data" %>

////

////

~~~js
❯ Posts.insert({
  title: 'Meteor Docs',
  author: 'Tom Coleman',
  url: 'http://docs.meteor.com'
});
~~~
<%= caption "Browser console" %>

////

<%= screenshot "4-4", "Adding posts via the console" %>

////

<% note do %>

### Inspecting DOM Changes

////

////

<% end %>

### Connecting Collections: Publications and Subscriptions

////

////

~~~bash
$ meteor remove autopublish
~~~

////

////

////

~~~js
Meteor.publish('posts', function() {
  return Posts.find();
});
~~~
<%= caption "server/publications.js" %>

////

~~~js
Meteor.subscribe('posts');
~~~
<%= caption "client/main.js" %>

<%= commit "4-4", "Removed `autopublish` and set up a basic publication." %>

////

### Conclusion

////
