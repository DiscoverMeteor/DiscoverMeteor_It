---
title: Pubblicazioni avanzate
slug: advanced-publications
date: 0013/01/02
number: 13.5
points: 10
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/8390558986/
photoAuthor: Mike Lewinski
contents: Impare delle tecniche più avanzate per manipolare le pubblicazioni.| Guarda quanto possono essere flessibili le pubblicazioni e le sottoscrizioni.
paragraphs: 36
---

A questo punto dovresti avere una buona comprensione di come pubblicazioni e sottoscrizioni interagiscono. Quindi cerchiamo di sbarazzarci delle ruote di supporto ed esaminare un paio di scenari avanzati.

### Pubblicare una collezione più volte

Nel [nostro primo approfondimento sulle pubblicazioni](/chapter/publications-and-subscriptions/), abbiamo visto alcune delle tecniche più comuni su pubblicazioni e sottoscrizioni, ora abbiamo imparato come la funzione `_publishCursor` le ha resi molto facili da implementare sui nostri siti.

Iniziamo ricordando cosa `_publishCursor` fa per noi esattamente: prende tutti i documenti che corrispondono a un certo cursore e li invia alla collezione *con lo stesso nome* sul client. Da notare che il nome della _pubblicazione_ non è coinvolto.

Questo significa che possiamo avere _più di una pubblicazione_ di collegamento tra le collezioni sul client e sul server.

Abbiamo già incontrato questo pattern nel nostro [capitolo  sulla paginazione](/chapter/pagination/), quando abbiamo pubblicato un sottoinsieme paginato di tutti i post in aggiunta al post corrente visualizzato.

Un altro simile caso d'uso è quello di pubblicare una *panoramica* di un grande set di documenti, come anche tutti i dettagli di un singolo elemento:

<%= diagram "doublecollection", "Pubblicare una collezione due volte", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

Ora, quando il client sottoscrive queste due pubblicazioni (utilizzando `autorun` per garantire che il giusto `postID` è stato inviato alla sottoscrizione `postDetail`), la sua collezione `'posts'` viene popolata da due sorgenti: un elenco di titoli ei nomi degli autori della prima sottoscrizione, e tutti i dettagli di un post dal secondo.

Si potrebbe notare che il post pubblicato da `postDetail` viene anche pubblicato da `allPosts` (anche se con solo un sottoinsieme delle sue proprietà). Tuttavia, Meteor si prende cura della sovrapposizione unendo i campi e garantendo che nessun post sia duplicato.

Questa è una bella cosa, perché ora quando renderizziamo l'elenco sommario dei post, gestiamo degli oggetti di dati che hanno sufficienti dati per mostrare quello che ci serve. Quindi quando rederizziamo la pagina per un singolo post, abbiamo tutto quello che serve per mostrarlo. Certo, abbiamo bisogno di prenderci cura sul client di non aspettarsi che tutti i campi siano disponibili su tutti i post - questa è una situazione comune!

Bisogna notare che non sei limitato a variare le proprietà del documento. Si potrebbe benissimo pubblicare le stesse proprietà di entrambe le pubblicazioni, ma ordinare gli elementi in modo diverso.

~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Sottoscrivere una pubblicazione più volte

Abbiamo appena visto come è possibile pubblicare una singola collezione più di una volta. Allo stesso modo si può realizzare un risultato molto simile con un altro pattern: la creazione di una singola pubblicazione, ma *sottoscrivendoci* più volte.

In Microscope, sottoscriviamo la pubblicazione `posts` più volte, ma Iron Router attiva e disattiva ogni sottoscrizione per noi. Però non c'è alcun motivo per cui non ci si possa sottoscrivere più volte *contemporaneamente*.

Ad esempio, diciamo che abbiamo voluto caricare sia i più recenti che i migliori post in memoria allo stesso tempo:

<%= diagram "subscribetwice", "Sottoscriversi due volte a una pubblicazione", "pull-center" %>

Stiamo impostando una singola pubblicazione:

~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

E poi sottoscriviamo questa pubblicazione più volte. In realtà questo è più o meno quello che stiamo facendo in Microscope:

~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

Quindi cosa sta succedendo qui esattamente? Ogni browser sta aprendo *due* sottoscrizioni differenti, ciascuna che si connette alla *stessa* pubblicazione sul server.

Ogni sottoscrizione fornisce diversi argomenti per tale pubblicazione, ma fondamentalmente, ogni volta un (diverso) set di documenti viene raccolto dalla collezione `posts` e trasferito sulla collezione client-side.

### Collezioni multiple in una singola sottoscrizione

////

////

////

////

////

////

////

<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////

////

~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;

  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] =
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }

  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });

  sub.ready();

  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////

////

////

### Linking different collections

////

<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

////

////

////

////

~~~js
  Meteor.publish('videos', function() {
    var sub = this;

    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');

    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

////

////
